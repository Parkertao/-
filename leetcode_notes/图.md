# 2022-4-20

### 200.岛屿数量

```c++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int res = 0;
        for (int i = 0; i < grid.size(); i++)
        {
            for (int j = 0; j < grid[0].size(); j++)
            {
                if (grid[i][j] == '1')
                {
                    res++;
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }
private:
    void dfs(vector<vector<char>>& grid, int i, int j)
    {
        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0') return;
        grid[i][j]='0';//把岛给淹了，真是妙，一直没想到这一步，搞死人
        dfs(grid, i+1, j);
        dfs(grid, i-1, j);
        dfs(grid, i, j+1);
        dfs(grid, i, j-1);
    }
};
```

图搜索的几个关键点：**建图，dfs、bfs等算法模板，标记访问**

### 547.省份数量

同上一题，都是搜索，并且做好标记，因为是相当于找连通性，所以一般都是用DFS。

```c++
class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        vector<int> path(isConnected.size(), 0);
        int res = 0;
        for (int i = 0; i < isConnected.size(); i++)
        {
            if (!path[i])
            {
                res++;
                dfs(isConnected, i, path);
            }
        }
        return res;
    }
private:
    void dfs(vector<vector<int>>& isConnected, int s, vector<int>& path)
    {
        path[s] = 1;
        for(int i = 0; i < isConnected.size(); i++)
        {
            if(isConnected[s][i]&& !path[i])
                dfs(isConnected, i, path);
        }
    }
};
```

### 1319.连通网络的操作次数

一开始的思路是通过dfs搜索有多少个连通分量，以及多少个多余的线缆，然后通过多余线缆数和连通分量数比较来判断是否能全部连接起来。但是dfs搜索来判断多余线缆数很困难。

看了题解才知道**根本不需要知道多余线缆，只需要总线缆数大于等于节点数减一即可**，证明也很简单，甚至说不用证明，一个图里如果用两个独立的连通分量，那么边数必然小于n-1，只要边数大于等于n-1，那么就可以通过断开重连使两个分量连通。

这样思路就变得十分简单，就是模板题了。

```c++
// 搜索找到有多少个网络，有多少多余的线缆
// 线缆数大于网络数减一，就可以实现全连通，否则不能
// 
// 思路错误的点：找到多少多余线缆比较困难，判断是否能全部连通，是通
// 过总线缆数和总节点数-1比较得到，这样就无需在搜索时关注多余线缆数

class Solution {
    void dfs(int v, vector<int>& vis, vector<vector<int>>& edge)
    {
        vis[v] = 1;
        for (auto e : edge[v])
        {
            if (!vis[e]) dfs(e, vis, edge);
        }
    }
public:
    int makeConnected(int n, vector<vector<int>>& connections) {
        if (connections.size() < n - 1) return -1;
        int nets = 0;
        vector<int> vis(n, 0);
        vector<vector<int>> edge(n);
        // 建图，邻接表
        for (auto v : connections)
        {
            edge[v[0]].push_back(v[1]);
            edge[v[1]].push_back(v[0]);
        }

        for (int i = 0; i < n; i++)
        {
            if (!vis[i])
            {
                dfs(i, vis, edge);
                nets++;
            }
        }
        return nets - 1;
    }
};
```

并查集解法

```c++
// 并查集模板
class UnionFind {
public:
    vector<int> parent;
    vector<int> size;
    int n;
    // 当前连通分量数目
    int setCount;
    
public:
    UnionFind(int _n): n(_n), setCount(_n), parent(_n), size(_n, 1) {
        iota(parent.begin(), parent.end(), 0); // 自增填充函数
    }
    
    int findset(int x) {
        return parent[x] == x ? x : parent[x] = findset(parent[x]);
    }
    
    bool unite(int x, int y) {
        x = findset(x);
        y = findset(y);
        if (x == y) {
            return false;
        }
        if (size[x] < size[y]) {
            swap(x, y);
        }
        parent[y] = x;
        size[x] += size[y];
        --setCount;
        return true;
    }
    
    bool connected(int x, int y) {
        x = findset(x);
        y = findset(y);
        return x == y;
    }
};

class Solution {
public:
    int makeConnected(int n, vector<vector<int>>& connections) {
        if (connections.size() < n - 1) {
            return -1;
        }

        UnionFind uf(n);
        for (const auto& conn: connections) {
            uf.unite(conn[0], conn[1]);
        }

        return uf.setCount - 1;
    }
};
```

